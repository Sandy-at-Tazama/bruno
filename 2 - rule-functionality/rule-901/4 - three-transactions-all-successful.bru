meta {
  name: 4 - three-transactions-all-successful
  type: http
  seq: 4
}

post {
  url: http://localhost:3001/natsPublish
  body: none
  auth: none
}

assert {
  res.status: eq 200
}

script:pre-request {
  const { generateFullMessageSet, prepGraphEntities, prepGraphAccountHolders, prepGraphTransactions, prepGraphAccounts } = require('tazama-test-utils');
  
  const axios = require('axios');
  
  const quoting = bru.getEnvVar('QUOTING') === 'true';
  
  const {  pacs002, pain001, pain013, pacs008, dataCache, creditor, debtor } = generateFullMessageSet(quoting, {
    amount: 1000,
    status: 'ACCC'
  })[0];
  
  
  const createArangoEndpoint = (database, collection) => {
    const url = bru.getEnvVar("DATABASE_URL");
    const endpoint = `${url}/_db/${database}/_api/document/${collection}`;
    console.log('sending request to', endpoint);
    return endpoint
  }
  
  const transactionHistoryDB = bru.getEnvVar("TRANSACTION_HISTORY_DATABASE");
  const pseudonymsDB = bru.getEnvVar("PSEUDONYMS_DATABASE");
  
  const pain001Collection = bru.getEnvVar("COLLECTION_TRANSACTION_HISTORY_PAIN001");
  const pain013Collection = bru.getEnvVar("COLLECTION_TRANSACTION_HISTORY_PAIN013");
  const pacs002Collection = bru.getEnvVar("COLLECTION_TRANSACTION_HISTORY_PACS002");
  const pacs008Collection = bru.getEnvVar("COLLECTION_TRANSACTION_HISTORY_PACS008");
  
  const accountsGraph = bru.getEnvVar("COLLECTION_GRAPH_ACCOUNTS");
  const entitiesGraph = bru.getEnvVar("COLLECTION_GRAPH_ENTITIES");
  const transactionRelationshipGraph = bru.getEnvVar("COLLECTION_GRAPH_TRANSACTION");
  const accountHoldersGraph = bru.getEnvVar("COLLECTION_GRAPH_ACCOUNT_HOLDERS");
  
  console.log('sending request');
  async function postData(pacs8, pacs2, dataCache, pain1 ,pain13) {
    let debtorId = pacs8.FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id;
    let creditorId = pacs8.FIToFICstmrCdtTrf.CdtTrfTxInf.Dbtr.Id.PrvtId.Othr[0].Id;
    let debtorAccountId = pacs8.FIToFICstmrCdtTrf.CdtTrfTxInf.DbtrAcct.Id.Othr[0].Id
    let creditorAccountId = pacs8.FIToFICstmrCdtTrf.CdtTrfTxInf.CdtrAcct.Id.Othr[0].Id
    let creDtTm;
  
    let currency = pacs8.FIToFICstmrCdtTrf.CdtTrfTxInf.InstdAmt.Amt.Ccy;
    let amount = pacs8.FIToFICstmrCdtTrf.CdtTrfTxInf.InstdAmt.Amt.Amt;
    let endToEndId = pacs8.FIToFICstmrCdtTrf.CdtTrfTxInf.PmtId.EndToEndId;
    let timestampPacs008 = pacs8.FIToFICstmrCdtTrf.GrpHdr.CreDtTm;
    let messageIdPacs008 = pacs8.FIToFICstmrCdtTrf.GrpHdr.MsgId;
  
    let timestampPacs002 = pacs2.FIToFIPmtSts.GrpHdr.CreDtTm;
    let messageIdPacs002 = pacs2.FIToFIPmtSts.GrpHdr.MsgId;
    let pacs002Sts = pacs2.FIToFIPmtSts.TxInfAndSts.TxSts;
  
    let quotingData;
  
    if (quoting && pain1 && pain13) {
      creDtTm = pain1.CstmrCdtTrfInitn.GrpHdr.CreDtTm;
      const timestampPain001 = pain1.CstmrCdtTrfInitn.GrpHdr.CreDtTm;
      const messageIdPain001 = pain1.CstmrCdtTrfInitn.GrpHdr.MsgId;
      const timestampPain013 = pain13.CdtrPmtActvtnReq.GrpHdr.CreDtTm;
      const messageIdPain013 = pain13.CdtrPmtActvtnReq.GrpHdr.MsgId;
      quotingData = {
        timestampPain001, messageIdPain001, timestampPain013, messageIdPain013  
      }
    } else {
      creDtTm = pacs8.FIToFICstmrCdtTrf.GrpHdr.CreDtTm;
    }
  
    let transactions = prepGraphTransactions(dataCache.dbtrAcctId, dataCache.cdtrAcctId, currency, amount, endToEndId, timestampPacs008, messageIdPacs008, timestampPacs002, messageIdPacs002, pacs002Sts, quotingData)
    const graphEntities = prepGraphEntities(debtorId, creditorId, creDtTm);
  
    const accountHolders = prepGraphAccountHolders(debtorId, debtorAccountId, creditorId, creditorAccountId, creDtTm);
  
    const accounts = prepGraphAccounts(debtorAccountId, creditorAccountId);
  
    if (quoting) {
      await axios.post(createArangoEndpoint(transactionHistoryDB, pain001Collection), { ...pain1, DataCache: dataCache });
      await axios.post(createArangoEndpoint(transactionHistoryDB, pain013Collection), {...pain13, DataCache: dataCache });
    }
  
    await axios.post(createArangoEndpoint(transactionHistoryDB, pacs008Collection), {...pacs8, DataCache: dataCache});
    await axios.post(createArangoEndpoint(transactionHistoryDB, pacs002Collection), {...pacs2, DataCache: dataCache});
    await axios.post(createArangoEndpoint(pseudonymsDB, accountsGraph), accounts);
    await axios.post(createArangoEndpoint(pseudonymsDB, entitiesGraph), graphEntities);
    await axios.post(createArangoEndpoint(pseudonymsDB, transactionRelationshipGraph), transactions);
    await axios.post(createArangoEndpoint(pseudonymsDB, accountHoldersGraph), accountHolders);
  
  }
  
  await postData(pacs008, pacs002, dataCache, pain001, pain013);
  
  
  const getRuleBody = (ruleId, ruleCfgVer, messageBody, dataCache) => {
    ruleId = ruleId ? ruleId : '901@1.0.0';
    ruleCfgVer = ruleCfgVer ? ruleCfgVer : '1.0.0';
    const natsPub = `pub-rule-${ruleId}`;
    const natsSub = `sub-rule-${ruleId}`;
    const msgId = messageBody.FIToFIPmtSts.GrpHdr.MsgId;
    return {
        "awaitReply": true,
        "destination": `${natsSub}`,
        "consumer": `${natsPub}`,
        "functionName": `${msgId}`,
        "message": {
            "transaction": messageBody,
            "DataCache": dataCache,
            "networkMap": {
                "name": "Step-by-step processor testing - rule output to NATS REST proxy",
                "active": true,
                "cfg": "1.0.0",
                "messages": [
                    {
                        "id": "004@1.0.0",
                        "cfg": "1.0.0",
                        "txTp": "pacs.002.001.12",
                        "typologies": [
                            {
                                "id": "typology_999@1.0.0",
                                "cfg": "1.0.0",
                                "rules": [
                                    {
                                        "id": `${ruleId}`,
                                        "cfg": `${ruleCfgVer}`
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },
            "metaData": {
                "prcgTmDP": 0,
                "traceParent": `00-postman-${msgId}-01`,
                "prcgTmCRSP": 0
            }
        }
    };
  }
  
  const ruleBody = getRuleBody('901@1.0.0', '1.0.0', pacs002, dataCache);
  
  const results = generateFullMessageSet(quoting, {
    firstSetTime: 3600000 * 4,
    status: 'ACCC'
  }, {creditor, debtor, count: 2});
  
  const promises = results.map((result)=> {
   return postData(result.pacs008, result.pacs002, result.dataCache, result.pain001, result.pain013);
  })
  
  await Promise.all(promises)
  
  req.setBody(ruleBody)
  
  
}

tests {
  const targetRuleResult = {
      "id": "901@1.0.0",
      "cfg": "1.0.0",
      "subRuleRef": ".02",
      "reason": "The debtor has performed two or three transactions to date",
      "desc": "Number of outgoing transactions - debtor"
  };
  
  let response = res.getBody().data.ruleResult;
  
  test("should return the same id", function() {
    expect(response.id).to.be.eql(targetRuleResult.id);
  });
  
  test("should return the same cfg", function() {
    expect(response.cfg).to.be.eql(targetRuleResult.cfg);
  });
  
  test("should return the same subRuleRef", function() {
    expect(response.subRuleRef).to.be.eql(targetRuleResult.subRuleRef);
  });
  
  test("should that result does not exist", function() {
    expect(response).to.not.have.property('result')
  });
  
  test("should that desc does not exist", function() {
    expect(response).to.not.have.property('desc')
  });
  
  test("should that reason does not exist", function() {
    expect(response).to.not.have.property('reason')
  });
}
